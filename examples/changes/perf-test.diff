diff --git a/peer/chaincode/batch_invoke.go b/peer/chaincode/batch_invoke.go
new file mode 100644
index 0000000..6df473d
--- /dev/null
+++ b/peer/chaincode/batch_invoke.go
@@ -0,0 +1,187 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package chaincode
+
+import (
+	"fmt"
+
+	"encoding/json"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/spf13/cobra"
+	"math/rand"
+	"strings"
+	"time"
+	"strconv"
+)
+
+var chaincodeBatchInvokeCmd *cobra.Command
+
+type MarbleCtor struct {
+	Function string   `json:"Function"`
+	Args     []string `json:"Args"`
+}
+
+func getRandomMarbleName(n int) string {
+	letters := []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890")
+
+	b := make([]rune, n)
+	for i := range b {
+		b[i] = letters[rand.Intn(len(letters))]
+	}
+	return string(b)
+}
+
+func getRandomInitMarbleCtor() []byte {
+	initMarbleCtor := &MarbleCtor{
+		Function: "initMarble",
+		Args:     []string{getRandomMarbleName(16), "blue", "100", "bob"},
+	}
+	bytes, _ := json.Marshal(initMarbleCtor)
+	return bytes
+}
+
+type batchRequest struct {
+	Spec     *pb.ChaincodeSpec
+	ChainID  string
+	invoke   bool
+	reqTimes chan<- requestTime
+}
+
+type requestTime struct {
+	startTime int64
+	endTime   int64
+}
+
+// invokeCmd returns the cobra command for Chaincode Invoke
+func batchInvokeCmd(cf *ChaincodeCmdFactory) *cobra.Command {
+	chaincodeBatchInvokeCmd = &cobra.Command{
+		Use:       "batchInvoke",
+		Short:     fmt.Sprintf("Invoke the specified %s.", chainFuncName),
+		Long:      fmt.Sprintf(`Invoke the specified %s. It will try to commit the endorsed transaction to the network.`, chainFuncName),
+		ValidArgs: []string{"1"},
+		RunE: func(cmd *cobra.Command, args []string) error {
+			return chaincodeBatchInvoke(cmd, args, cf)
+		},
+	}
+
+	return chaincodeBatchInvokeCmd
+}
+
+func chaincodeBatchInvoke(cmd *cobra.Command, args []string, cf *ChaincodeCmdFactory) error {
+	if err := checkChaincodeCmdParams(cmd); err != nil {
+		return err
+	}
+	reqCount, err := strconv.Atoi(batchSize)
+	if err != nil {
+		return err
+	}
+	workers, err := strconv.Atoi(workerCount)
+	if err != nil {
+		return err
+	}
+
+	cfs, err := initCmdFactories(workers)
+	if err != nil {
+		return err
+	}
+	defer closeCmdFactories(cfs)
+	rand.Seed(time.Now().UnixNano())
+
+	requests := make(chan batchRequest, workers * 4)
+	reqTimes := make(chan requestTime, 1000)
+	done := make(chan struct{}, workers)
+
+	go buildInvokeRequests(requests, reqCount, reqTimes)
+	batchStartTime := time.Now().UnixNano()
+	for i := 0; i < workers; i++ {
+		go doChaincodeInvoke(done, cfs[i], requests)
+	}
+	go awaitCompletion(done, workers, reqTimes)
+
+	var count, sumDuration int64
+	for reqTime := range reqTimes {
+		count++
+		sumDuration += reqTime.endTime - reqTime.startTime
+	}
+	batchEndTime := time.Now().UnixNano()
+
+	logger.Warning("req count:", count, "batch Time(seconds):", time.Duration(batchEndTime - batchStartTime).String())
+	logger.Warning("workers:", workers, "Seq Time(seconds)", time.Duration(sumDuration).String())
+
+	return nil
+}
+
+func initCmdFactories(n int) ([]*ChaincodeCmdFactory, error) {
+	cfs := make([]*ChaincodeCmdFactory, n)
+	var err error
+	for i := 0; i < n; i++ {
+		if cfs[i], err = InitCmdFactory(); err != nil {
+			closeCmdFactories(cfs)
+			return cfs, err
+		}
+	}
+
+	return cfs, nil
+}
+
+func closeCmdFactories(cfs []*ChaincodeCmdFactory) {
+	for i, cf := range cfs {
+		if cf != nil {
+			cf.BroadcastClient.Close()
+			cfs[i] = nil
+		}
+	}
+}
+
+func buildInvokeRequests(requests chan<- batchRequest, reqCount int, reqTimes chan<- requestTime) {
+	for i := 0; i < reqCount; i++ {
+		spec := &pb.ChaincodeSpec{}
+		// Build the spec
+		input := &pb.ChaincodeInput{}
+		if err := json.Unmarshal(getRandomInitMarbleCtor(), &input); err != nil {
+			logger.Warning("Chaincode argument error: %s \n", err.Error())
+			return
+		}
+
+		chaincodeLang = strings.ToUpper(chaincodeLang)
+		spec = &pb.ChaincodeSpec{
+			Type:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[chaincodeLang]),
+			ChaincodeId: &pb.ChaincodeID{Path: chaincodePath, Name: chaincodeName, Version: chaincodeVersion},
+			Input:       input,
+		}
+
+		requests <- batchRequest{spec, chainID, true, reqTimes}
+	}
+	close(requests)
+}
+
+func doChaincodeInvoke(done chan<- struct{}, cf *ChaincodeCmdFactory, requests <-chan batchRequest) {
+	for req := range requests {
+		startTime := time.Now().UnixNano()
+		ChaincodeInvokeOrQuery(req.Spec, req.ChainID, req.invoke, cf.Signer, cf.EndorserClient, cf.BroadcastClient)
+		endTime := time.Now().UnixNano()
+		req.reqTimes <- requestTime{startTime, endTime}
+	}
+	done <- struct{}{}
+}
+
+func awaitCompletion(done <-chan struct{}, n int, reqTimes chan requestTime) {
+	for i := 0; i < n; i++ {
+		<-done
+	}
+	close(reqTimes)
+}
diff --git a/peer/chaincode/chaincode.go b/peer/chaincode/chaincode.go
index 36d1e06..b2535a0 100644
--- a/peer/chaincode/chaincode.go
+++ b/peer/chaincode/chaincode.go
@@ -56,6 +56,10 @@ func AddFlags(cmd *cobra.Command) {
 		fmt.Sprint("The name of the endorsement system chaincode to be used for this chaincode"))
 	flags.StringVarP(&vscc, "vscc", "V", common.UndefinedParamValue,
 		fmt.Sprint("The name of the verification system chaincode to be used for this chaincode"))
+	flags.StringVarP(&batchSize, "batchSize", "b", common.UndefinedParamValue,
+		fmt.Sprint("size of batch invoke"))
+	flags.StringVarP(&workerCount, "workerCount", "w", "10",
+		fmt.Sprint("concurrent worker count"))
 }
 
 // Cmd returns the cobra command for Chaincode
@@ -68,6 +72,7 @@ func Cmd(cf *ChaincodeCmdFactory) *cobra.Command {
 	chaincodeCmd.AddCommand(upgradeCmd(cf))
 	chaincodeCmd.AddCommand(packageCmd(cf))
 	chaincodeCmd.AddCommand(installCmd(cf))
+	chaincodeCmd.AddCommand(batchInvokeCmd(cf))
 
 	return chaincodeCmd
 }
@@ -88,6 +93,8 @@ var (
 	escc              string
 	vscc              string
 	policyMarhsalled  []byte
+	batchSize	  string
+	workerCount	  string
 )
 
 var chaincodeCmd = &cobra.Command{
